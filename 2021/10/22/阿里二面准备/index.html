<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>技术、生活、思考</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="技术、生活、思考" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">技术、生活、思考</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/categories/" class="menu-item-link">Categories</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags/" class="menu-item-link">Tags</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title"></h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-10-22</span>
  </div>
  <div class="post-content">
    <h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h3 id="1-什么是分布式事务"><a href="#1-什么是分布式事务" class="headerlink" title="1. 什么是分布式事务"></a>1. 什么是分布式事务</h3><p>答：为了操作不同数据库的不可分割的一系列操作“要么什么都不做，要么全套”的机制。</p>
<h3 id="2-几种常见的分布式事务"><a href="#2-几种常见的分布式事务" class="headerlink" title="2. 几种常见的分布式事务"></a>2. 几种常见的分布式事务</h3><p>答：看下<a href="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E5%88%86%E5%B8%83%E5%BC%8F.md">分布式.md文件</a></p>
<h3 id="3-缓存和DB不一致（cache-aside）"><a href="#3-缓存和DB不一致（cache-aside）" class="headerlink" title="3. 缓存和DB不一致（cache aside）"></a>3. 缓存和DB不一致（cache aside）</h3><p>答：<br>Cache Aside Pattern</p>
<ol>
<li> 读的时候，先读缓存，缓存没有的话，那么就去数据库读，然后取出数据后放入缓存，同时返回响应；</li>
<li>更新的时候，先删除缓存，然后再更新数据库；</li>
</ol>
<p>![Cache Aside Pattern](/Users/xiazhenyu/Desktop/typora文件集合/文档合集/Cache Aside Pattern.png)</p>
<p>三种常见的方法及问题：</p>
<ul>
<li><p>先更新数据库，再更新缓存</p>
<ol>
<li>ABBA问题：<br>同时有A、B两个线程进行更新操作：<br>1）线程A更新了数据库；<br>2）线程B更新了数据库；<br>3）线程B更新了缓存；<br>4）线程A更新了缓存；<br>线程B比线程A更早更新了缓存，导致脏数据的出现。</li>
<li>业务上：对于写多读少的场景，就会导致数据没有读请求，但是被频繁的更新，浪费性能；另一方面，缓存的计算比较复杂的话，也会导致性能浪费；</li>
</ol>
</li>
<li><p>先更新缓存，再更新数据库：<br>和上面是同样的问题；</p>
</li>
<li><p>先删除缓存，再更新数据库<br>ABBBA问题<br>会导致不一致的情况出现，没有过期时间的话，数据永远都是有问题的。可以采用延迟一段时间，再次删除解决；</p>
</li>
<li><p>先更新数据库，再删除缓存<br>1）缓存刚好失效；<br>2）请求A查询数据库，得到一个旧值；<br>3）请求B将新值写入数据库；<br>4）请求B删除缓存；<br>5）请求A将查询到的旧值写入缓存；<br>上面成立的前提是数据库写请求比读请求还要快，实际上，工程中数据库的读操作的速度要远快于写操作的。</p>
</li>
<li><p>双写一致性：</p>
<ol>
<li>缓存不能读到脏数据；</li>
<li>缓存可能会读到过期数据，但要在可容忍的一段时间内实现最终一致性；</li>
<li>可容忍时间要尽可能小；</li>
</ol>
<p>方案：采用读请求和写请求串行化，串到一个内存队列中去，这样就可以保证一定不会出现不一致的情况。但是串行化之后，系统的吞吐量就会下降，需要更多的机器去支撑；</p>
</li>
</ul>
<h3 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4. MVCC"></a>4. MVCC</h3><ul>
<li>概念：<br>MVCC(Multi Version Concurrency Control)被称为多版本控制，是指在数据库中为了实现高并发的 数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。 多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。如何生成的多版本?每次事务修改操作之前，都会在Undo日志中记录修改之前的数据状态和事务号， 该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。</li>
<li>MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作</li>
<li>原理：<br>用排他锁锁定该行;记录 Redo log;<br>把该行修改前的值复制到 Undo log，即图中下面的行;<br>修改当前行的值，填写事务编号，使回滚指针指向 Undo log 中修改前的行。<br><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/MVCC%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="MVCC原理图"></li>
</ul>
<h3 id="5-分布式锁的使用情况、和Redission的区别"><a href="#5-分布式锁的使用情况、和Redission的区别" class="headerlink" title="5. 分布式锁的使用情况、和Redission的区别"></a>5. 分布式锁的使用情况、和Redission的区别</h3><h4 id="redis分布式锁："><a href="#redis分布式锁：" class="headerlink" title="redis分布式锁："></a>redis分布式锁：</h4><ul>
<li><p>setNx命令+Lua脚本；<br>使用Lua脚本保证原子性；</p>
<p>存在的问题：</p>
<ol>
<li>单机无法保证高可用性；</li>
<li>主-从结构，无法保证数据的强一致性；在主机宕机时会造成锁的重复获得；</li>
<li>无法续租：超过expireTime以后，不能继续使用；</li>
</ol>
</li>
<li><p>redisson客户端：</p>
</li>
</ul>
<p>​                         <img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/Redisson%E7%BB%AD%E7%A7%9F%E6%9C%BA%E5%88%B6.png" alt="Redisson续租机制"></p>
<p>加锁：如果客户端面临的是一个redis cluster 集群，首先会根据hash节点选择一台机器；</p>
<ol>
<li>发送lua脚本到redis服务器上；</li>
<li>使用<code>exists myLock</code> 命令判断一下，如果key不存在的话，就进行加锁，使用<code>hset myLock</code>命令，需要注意的是value是客户端的Id（UUID）+线程id,并设置过期时间；</li>
<li>如果了另一个客户端请求，会发现key已经存在，然后判断hash数据结构中是否包含客户端2的id，没有的话，返回key的剩余生存时间；这个时候，客户端2会继续尝试获取；</li>
<li>一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每个10s检查下，如果客户端1还持有锁，就会不断延长key的生存时间；</li>
<li>重入：如果客户端1再次加锁，就会将hash数据结构中的值加一；</li>
</ol>
<p>解锁：每次对myLock数据结构中的那个加锁次数减1。如果发现是0了，说明这个客户端已经不再持有锁了，那么这个时候就可以删除这个key了，同时会发布一个redis解锁的消息给其他的客户端；如果不是0，就会继续延长这个锁的超时时间；</p>
<h4 id="zk与Etcd"><a href="#zk与Etcd" class="headerlink" title="zk与Etcd"></a>zk与Etcd</h4><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/3%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="3种分布式锁的区别"></p>
<h4 id="分布式锁特性："><a href="#分布式锁特性：" class="headerlink" title="分布式锁特性："></a>分布式锁特性：</h4><ol>
<li>互斥性；</li>
<li>同一性；</li>
<li>可重入性；</li>
<li>容错性；</li>
</ol>
<p>使用场景：数据的并发竞争、防止库存超卖（不适合秒杀，秒杀使用CAS和redis队列）</p>
<h3 id="6-消息"><a href="#6-消息" class="headerlink" title="6.消息"></a>6.消息</h3><h4 id="pulsar的架构？为什么使用pulsar？"><a href="#pulsar的架构？为什么使用pulsar？" class="headerlink" title="pulsar的架构？为什么使用pulsar？"></a>pulsar的架构？为什么使用pulsar？</h4><ol>
<li><p>pulsar的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息的复制；</p>
</li>
<li><p>极低的发布延迟和端到端延迟；</p>
</li>
<li><p>可无缝扩展超过100万个topic；</p>
</li>
<li><p>简单的API；</p>
</li>
<li><p>支持多种topic订阅模式</p>
<p>5.1 共享式：多个client可以订阅同一个topic。消息以轮训的方式分布在各个client之间，任何给定的消息仅传递给一个client。当client断开链接的时候，会将未消费的消息发送给其他的消费者。</p>
<p>5.2 独占式（exclusive）：近允许单个消费者订阅Topic；</p>
<p>5.3 故障转移模式:<br>多个client可以订阅同一个topic。为主消费者选择非分区主题或分区主题的每个分区，并接受消息。当主使用者断开连接时，所有消息将被传递到排队的下一个使用者。<br>对于分区主题，代理将按优先级和消费者的名字的字典顺序对消费者进行消费。然后，代理将尝试将主题平均分配给优先级最高的消费者；<br>对于非分区主题，代理将按订阅非分区主题的顺序选择消费者；</p>
</li>
<li><p>使用Apache BookKeeper（又称 bookies）提供的持久化消息存储机制保证消息的传递；</p>
</li>
</ol>
<p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/pulsar%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="pulsar架构图"></p>
<p>组成部分： </p>
<ul>
<li>Broker： <ol>
<li>负责处理和负载均衡 producer 发出的消息，并将这些消息分派给 consumer；</li>
<li>Broker 与 Pulsar 配置存储交互来处理相应的任务，并将消息存储在 BookKeeper 实例中（又称 bookies）；</li>
<li>Broker 依赖 ZooKeeper 集群处理特定的任务；</li>
</ol>
</li>
<li>Bookies：负责消息的存储，BookKeeper是一个分布式的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Write-ahead_logging">预写日志（WAL）</a>系统</li>
<li>ZK：用于集群级别的配置和协调;</li>
</ul>
<p><a href="!https://pulsar.apache.org/docs/zh-CN/concepts-architecture-overview/">架构说明</a></p>
<h4 id="6-JVM"><a href="#6-JVM" class="headerlink" title="6.JVM"></a>6.JVM</h4><img src="/Users/xiazhenyu/Desktop/typora文件集合/文档合集/JVM内存模型以及GC相关知识点.jpg" alt="JVM内存模型以及GC相关知识点" style="zoom:200%;" />

<h3 id="7-rpc"><a href="#7-rpc" class="headerlink" title="7.rpc"></a>7.rpc</h3><h3 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8. 多线程"></a>8. 多线程</h3><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="线程的生命周期"></p>
<p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="线程池的执行流程"></p>
<h2 id="比较好的项目介绍"><a href="#比较好的项目介绍" class="headerlink" title="比较好的项目介绍"></a>比较好的项目介绍</h2><h4 id="titan项目"><a href="#titan项目" class="headerlink" title="titan项目"></a>titan项目</h4><p>注意：为什么离职千万不能说因为钱！</p>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    chenyusharp
  </span>
</footer>
    </div>
  </body>
</html>