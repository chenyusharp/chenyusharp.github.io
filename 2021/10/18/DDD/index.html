<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>技术、生活、思考</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="技术、生活、思考" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">技术、生活、思考</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/categories/" class="menu-item-link">Categories</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags/" class="menu-item-link">Tags</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title"></h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-10-18</span>
  </div>
  <div class="post-content">
    <p>[TOC]</p>
<h2 id="DDD与微服务的关系"><a href="#DDD与微服务的关系" class="headerlink" title="DDD与微服务的关系"></a>DDD与微服务的关系</h2><h2 id="各种域"><a href="#各种域" class="headerlink" title="各种域"></a>各种域</h2><p>领域：限定业务边界和范围，然后在这个边界内解决业务问题；</p>
<p>子域：领域可以进一步划分为子领域，多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围；</p>
<p>核心域：决定产品和公司核心竞争力的子域是核心域；</p>
<p>通用域：没有太多个性化诉求，同时被多个子域使用的通用功能子域是通用域（权限、认证）；</p>
<p>支撑域：不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，就是支撑域；</p>
<p>商品的额核心域：基础资料、商家商品、营业部商品；<br>通用域：权限、认证；<br>支撑域：品牌、类目、属性、BOM关系；</p>
<h2 id="领域模型与服务"><a href="#领域模型与服务" class="headerlink" title="领域模型与服务"></a>领域模型与服务</h2><h3 id="微服务与模型"><a href="#微服务与模型" class="headerlink" title="微服务与模型"></a>微服务与模型</h3><h4 id="什么是领域服务？"><a href="#什么是领域服务？" class="headerlink" title="什么是领域服务？"></a>什么是领域服务？</h4><p>当领域中的某个操作过程不是实体或值对象的职责时，此时我们便应该将该操作放在一个单独的接口中，即领域服务，然后它是无状态的。以下场景可以放到领域服务中：</p>
<ul>
<li>执行一个显著的业务操作过程；</li>
<li>对领域对象进行转换；</li>
<li>以多个领域对象作为输入进行计算，结果产生一个值对象；</li>
</ul>
<p>Q：微服务的粒度？微服务如何拆分和设计？微服务的边界在哪里？</p>
<p>A：需要确定业务或者是微服务的边界。</p>
<p>DDD的核心：通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型和代码模型的一致性。</p>
<p>Q：为什么DDD适合微服务？<br>A：DDD是一种处理高度复杂领域的设计思想。它可以分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务<br>的复杂性，以解决软件难以理解、难以演进的问题。DDD是一种架构设计方法论，它通过边界划分将业务领域简单化，以利于<br>设计出清晰的领域和应用边界，可以很容易地实现架构的演进。</p>
<p>Q：如何划定领域模型和微服务的边界？<br>A：<br>第一步：在事件风暴中梳理业务过程中的==用户操作==、==事件以及外部依赖关系==，根据这些要素梳理出领域实体等领域对象；<br>第二步：根据业务的关联性，将==业务紧密相关==的实体进行组合形成聚合，确定聚合中的==聚合根==、==值对象==和==实体==。所以说：<br>这些聚合是在==同一个微服务实例==中运行；<br>第三步：将一个或者多个聚合划定在一个界限上下文内，形成==领域模型==，用以划分微服务的边界，是物理隔离的。不同的界限<br>上下文是在不同的微服务实例中运行的。界限上下文可以用来划分具体的领域边界。</p>
<p>PS：事件风暴：<br>建立领域模型的主要方法。包括用例分析、场景分析、用户旅程分析，梳理领域对象之间的关系。建立实体、命令、事件</p>
<p>Q：DDD与微服务的关系？</p>
<p>A：<br>DDD是一种架构设计方法，微服务是一种架构风格，两者都是为了追求高响应力，从业务视角去分离应用系统建设复杂度的手段；</p>
<p>DDD主要关注：从业务领域视角划分领域边界，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性；</p>
<p>微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注的是开发、测试、构建、部署；</p>
<h3 id="什么是界限上下文？"><a href="#什么是界限上下文？" class="headerlink" title="什么是界限上下文？"></a>什么是界限上下文？</h3><p>用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。在这个边界内定义了模型的适用范围，使团队所有成员能够明确知道什么应该在模型中实现，什么不应该在模型中实现（本领域的职责，就比如商品中的销售商品、货品、主档等的关系。销售商品的界限上下文就可以理解为商家销售商品的领域边界，当然也可以理解为地点销售商品的子领域边界。货品的界限上下文也可以这么理解。这个东西划定了领域服务的边界）。</p>
<h2 id="相爱相杀（聚合根-实体-值对象）"><a href="#相爱相杀（聚合根-实体-值对象）" class="headerlink" title="相爱相杀（聚合根-实体-值对象）"></a>相爱相杀（聚合根-实体-值对象）</h2><p>实体和值对象是组成领域模型的基础单元。</p>
<h3 id="什么是实体？"><a href="#什么是实体？" class="headerlink" title="什么是实体？"></a>什么是实体？</h3><p>A：实体是领域模型中的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。业务依存度高和业务关联紧密的多个实体对象和值对象进行聚合，形成聚合根。（类比商品，商家商品就是有商家商品基础信息+sku信息+图文描述信息等多个实体聚合而成的。它们对应的业务对象都是商家商品业务，相互之间有很强的依存关系。）</p>
<p>代码处理逻辑：在DDD中，这些实体类通常采用充血模型，与这个实体类相关的所有业务逻辑都在这个实体类中实现，跨多个实体类的领域逻辑在==领域服务==中实现。<br>Q：实体是怎么映射到数据库中的表的？都有哪些方式？<br>A：领域模型映射到数据模型，大多数情况下是一对一的，但是也会存在一对多、多对一等场景。举例：<br>一对一：商家商品基础信息、sku信息等；<br>一对多：权限实体对应用户user、角色role两个持久化对象；<br>多对一：客户和账户两个实体对象有可能对应同一个数据持久化对象；</p>
<h3 id="什么是值对象？"><a href="#什么是值对象？" class="headerlink" title="什么是值对象？"></a>什么是值对象？</h3><p>这个是一个更为抽象的东西。<br>通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在DDD中用来描述领域的特定方面，并且是一个没有标识符的对象，叫做值对象。<br>值对象本质上就是一个集。是若干个用于描述目的、具有整体概念和不可修改的属性。在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎。<br>（就是一些列具有特殊语义的属性的集合，这些属性各自分开有可能比较的零碎，组合起来可能具有更为完整的概念。）<br>值对象与实体一样，同样是从事件风暴中构建出来的。与实体对象的区别：值对象只有==数据初始化操作和有限的不涉及修改数据的行为==，基本不包含业务逻辑。<br>（从业务实际上看，实体中的每一个属性都可以理解为是一个单一的属性值对象。只有多个属性集值对象的集合，我们可以把它们单独出来作为一个class来创建。这个可以类比商品图文实体中的图文描述字段–description，我们就可以把Description作为一个值对象来看待。对于一个description值对象而言，它是有几个属性的集合组成的，而且这个值对象是不需要用唯一的Id进行标识的）。</p>
<h4 id="数据持久化设计？"><a href="#数据持久化设计？" class="headerlink" title="数据持久化设计？"></a>数据持久化设计？</h4><p>在领域建模的时候，我们可以将对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。<br>（说白了就是作为领域对象，实体要和值对象分来，但是值对象是要有一个属性保存在实体中的，在数据库中，值对象是序列化为一个字段保存在实体对应的一个表中的）。</p>
<h4 id="实体和值对象之间的关系？"><a href="#实体和值对象之间的关系？" class="headerlink" title="实体和值对象之间的关系？"></a>实体和值对象之间的关系？</h4><p>实体和值值对象是微服务底层的最基础的对象。实现了最核心的领域逻辑。</p>
<p>（具体的关系，可以参考前面的描述，简而言之，就是实体是有业务操作行为与逻辑的，而值对象只是一系列属性的集合，操作而言也大多是数据初始化与展示，没有复杂的修改）。</p>
<h2 id="聚合与聚合根？"><a href="#聚合与聚合根？" class="headerlink" title="聚合与聚合根？"></a>聚合与聚合根？</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>领域模型内的实体和值对象都是一个个体，是很基础的领域对象，实现了个体对应的业务操作。而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑的同时，能保证数据的一致性。是数据修改和持久化的基本单元。<br>（白话，聚合定义了数据库事务操作的基本单元，比如操作商家商品的修改，这个大的事务中应该包含哪些操作呢？比如包括商家商品础信息的修改、图文的修改、sku的修改等，这些内容的修改需要在一个统一的事务中，确保是一个原子化的操作）。</p>
<h4 id="高内聚和低耦合"><a href="#高内聚和低耦合" class="headerlink" title="高内聚和低耦合"></a>高内聚和低耦合</h4><p>聚合在DDD分层架构中属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，实体之间通过在领域服务中实现业务逻辑的高内聚。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务（业务服务）来实现。<br>（从上面的描述可以看出，聚合是一个动作，是对实体和对值对象的一种==组织==。）</p>
<h3 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h3><p>如果把聚合比做组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅仅是实体，还是聚合的管理者——负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。<br>==聚合之间，需要通过聚合根的ID来进行交互。==</p>
<h3 id="如何设计聚合根？"><a href="#如何设计聚合根？" class="headerlink" title="如何设计聚合根？"></a>如何设计聚合根？</h3><ol>
<li>在一致性边界内建模真正的不变条件。（意思就是这个边界内的各个实体和值对象是按照统一的业务规则来运行的）；</li>
<li>设计小聚合。（一个聚合内不宜包含过多的实体和值对象）；</li>
<li>通过唯一的标识（ID）来引用其他的聚合。这样可以最大限度的降低聚合之间的耦合度；</li>
<li>在边界之外适用最终一致性；<br>在一次事务中，只能修改一个聚合的状态。如果一次业务操作涉及多个聚合状态的修改，应该采用==领域事件==的方式异步修改相关的聚合，实现聚合之间的解耦（异步线程？MQ？）。</li>
<li>通过应用层实现跨聚合的服务调用。（在业务服务中调用各个聚合服务，也即领域服务）；</li>
</ol>
<h2 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h2><h3 id="什么是领域事件？"><a href="#什么是领域事件？" class="headerlink" title="什么是领域事件？"></a>什么是领域事件？</h3><p>是一种架构风格或者是编程范式。解决了不同的聚合根之间的耦合的问题。在集合根完成更新操作以后会产生一个新的事件并广播出去，由其他订阅该事件的订阅者完成其他的聚合根的对应的操作。这样就实现了不同的聚合根之间的解耦。</p>
<h3 id="领域事件怎么实现？"><a href="#领域事件怎么实现？" class="headerlink" title="领域事件怎么实现？"></a>领域事件怎么实现？</h3><ol>
<li>建模。领域事件是一个对象，同样需要建模，定义它的数据结构。领域事件的名称的格式一般为产生这个事件的聚合根的名字+产生事件的动词的过去式。比如说MerchantItemCreated。</li>
<li>内部的数据结构。一般与产生它的聚合根的很相似。除此之外，还会多两个属性：事件的发生日期、事件的唯一编号。</li>
</ol>
<p>处理时需要注意的几点：</p>
<ol>
<li>领域事件是领域逻辑的一部分，所以在领域层不应该依赖某些底层的框架或是中间件，</li>
<li>事件的发送应该是异步非阻塞的，不应该阻塞当前处理的线程；</li>
<li>设计上避免事件链的产生，即一个事件被处理后又产生了另一个事件；</li>
<li>考虑最终一致性的解决方案，记录好日志，以及事件丢失的处理与排查方案；</li>
</ol>
<ol start="3">
<li>框架的选择：<br>可以选择使用Sprint中的事件、订阅功能，或者是Guava中的EventBus；</li>
</ol>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    chenyusharp
  </span>
</footer>
    </div>
  </body>
</html>