<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术、生活、思考</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-23T08:51:40.659Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chenyusharp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL相关知识点</title>
    <link href="http://example.com/2022/03/23/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/MySQL%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/03/23/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/MySQL%E7%9B%B8%E5%85%B3/</id>
    <published>2022-03-23T08:34:23.641Z</published>
    <updated>2022-03-23T08:51:40.659Z</updated>
    
    <content type="html"><![CDATA[<p>字段类型相关：</p><p>日期类型的 DATETIME与TIMESTAMP的区别</p><ul><li>DATETIME：</li></ul><p>存储包含日期和时间的值。显示的格式为：<code>YYYY-MM-DD HH:MM:SS</code></p><p>范围为：<code>1000-01-01 00:00:00</code>至<code>9999-12-31 23:59:59</code></p><p>默认使用5个字节进行存储。也可以增加小数位，格式为<code>YYYY-MM-DD HH:MM:SS [.fraction]</code>。但当增加了小数秒精度以后，需要更多的存储空间。增加的字节如下：</p><table><thead><tr><th>分数秒精度</th><th>存储字节</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1，2</td><td>1</td></tr><tr><td>3，4</td><td>2</td></tr><tr><td>5，6</td><td>3</td></tr></tbody></table><ul><li>TIMESTAMP</li></ul><p>存储包含日期和时间的值。显示格式同DATETIME。</p><p>存储的范围是：<code>1970-01-01 00:00:01 UTC</code>到<code>2038-01-19 03:14:07 UTC</code>。可以看到，TIMESTAMP中存储的范围少于DATETIME。</p><p>TIMESTAMP使用4个字节进行存储。如果要存储分数秒精度的话，也需要额外的存储空间。</p><ul><li>两者的区别</li></ul><p>MySQL将TIMESTAMP存储在UTC时区中，而DATETIME是没有时区之分的。</p><p>在向TIMESTAMP字段插入值时，MySQL会将其从连接的时区转换为UTC后进行存储，而在查询的时候，MySQL会讲UTC值转换为当前连接的时区对应的值。也就是说，切换时区以后，获得的值就和数据库中存储的值不一样。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字段类型相关：&lt;/p&gt;
&lt;p&gt;日期类型的 DATETIME与TIMESTAMP的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DATETIME：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储包含日期和时间的值。显示的格式为：&lt;code&gt;YYYY-MM-DD HH:MM:SS&lt;/code&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>财务核算项目</title>
    <link href="http://example.com/2022/03/21/wholee/%E8%B4%A2%E5%8A%A1%E6%A0%B8%E7%AE%97%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2022/03/21/wholee/%E8%B4%A2%E5%8A%A1%E6%A0%B8%E7%AE%97%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-03-21T08:32:35.466Z</published>
    <updated>2022-03-22T06:20:40.965Z</updated>
    
    <content type="html"><![CDATA[<p>需求PRD地址：</p><p><a href="http://wiki.huoli101.com/pages/viewpage.action?pageId=60388365">http://wiki.huoli101.com/pages/viewpage.action?pageId=60388365</a></p><p><a href="http://wiki.huoli101.com/pages/viewpage.action?pageId=60388224">http://wiki.huoli101.com/pages/viewpage.action?pageId=60388224</a></p><p>产品原型：<a href="https://15d977.axshare.com/">https://15d977.axshare.com</a></p><p>数仓数据处理：<a href="http://wiki.huoli101.com/pages/viewpage.action?pageId=60390557">http://wiki.huoli101.com/pages/viewpage.action?pageId=60390557</a></p><h2 id="业务点"><a href="#业务点" class="headerlink" title="业务点"></a>业务点</h2><ul><li><p>一个完整的凭证是会对应好几个凭证规则的，不同的凭证规则映射了不同的科目编码+借贷方向，</p></li><li><p>一个完整的凭证总是包含借方金额和贷方金额的，并且借方金额总和总是等于贷方金额总和。 借方金额和贷方金额会有不同的明细组成。</p></li><li><p>需要一个记录校验失败的表，用以记录凭证校验失败的信息，对应于凭证失败列表；</p></li><li><p> 辅助核算：只是校验辅助核算中的项在数仓推过来的数据中是不是含有，特殊的，excel中的存货类别给默认值；</p></li><li><p>凭证中字段需要和excel中保持一致，而不是凭证的列表页；</p></li><li><p>汇总明细中的单号由核算系统生成，并且需要把这个值和生成的凭证数据、凭证失败数据关联起来；</p></li><li><p>金额的校验需要有技术上的校验，是否数字、大小范围限定等；</p></li><li><p>凭证规则的唯一性约束：业务码 + 账薄 + 科目编码；</p></li><li><p>借贷不平的校验，是在一条汇总数据的所有匹配的凭证规则的最后进行的，会统计对应的所有凭证规则对应的明细数据的借方金额总和是不是和贷方金额总和是否一致；</p></li><li><p>外币核算：一方面需要校验汇总数据中的币别是不是和匹配的凭证规则中的外币核算的值一致；另方面，如果外币核算配置的不是RMB，则需要根据汇率换算成RMB；</p></li><li><p>校验汇率：我理解就是查询汇率的换算规则存不存在；</p></li><li><p>供应商维护的配置中，唯一性约束是供应商名称；</p></li><li><p>凭证是可以物理删除的；</p></li></ul><p>excel部分</p><ul><li><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220322103352489.png" alt="image-20220322103352489" style="zoom:50%;" /></li></ul><p>这两个日期取的是数仓推过来的日期；</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220322110930947.png" alt="image-20220322110930947" style="zoom:50%;" /><p>==待确认的项：==</p><ul><li>凭证列表页的展示；</li><li>数仓推过来的汇总明细中的单号的校验逻辑；</li></ul><h2 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h2><p>主要分为三大类：</p><ol><li><p>汇总数据类表：</p></li><li><p>凭证表、凭证失败表（记录校验失败信息）（可以考虑通用的记录表设计）：</p></li></ol><p>凭证表设计：</p><table><thead><tr><th>no</th><th>类型</th><th>字段名</th><th>是否可为空</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>表头</td><td>id</td><td></td><td>20210313001</td></tr><tr><td></td><td></td><td>number</td><td></td><td>单号(以天为纬度，每天从1自增)</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td>date</td><td></td><td>日期（数仓推送时间）</td></tr><tr><td>3</td><td></td><td>account_year</td><td></td><td>会计期间-年</td></tr><tr><td>4</td><td></td><td>account_month</td><td></td><td>会计期间-月</td></tr><tr><td></td><td></td><td>certificate_code</td><td></td><td>凭证编码，固定值: PRE001</td></tr><tr><td>5</td><td></td><td>certificate_name</td><td></td><td>凭证字，固定值：记</td></tr><tr><td>6</td><td></td><td>certificate_number</td><td></td><td>凭证号 ==（excel导出的时候，字段为空）==</td></tr><tr><td>7</td><td>表体</td><td>summary</td><td>N</td><td>摘要</td></tr><tr><td>8</td><td></td><td>subject_code</td><td>N</td><td>科目编码</td></tr><tr><td>9</td><td></td><td>subject_full_name</td><td>N</td><td>科目全称</td></tr><tr><td></td><td></td><td>assist_account</td><td>Y</td><td>辅助核算</td></tr><tr><td></td><td></td><td>currency_number</td><td>N</td><td>货币代码</td></tr><tr><td>10</td><td></td><td>currency_code</td><td>N</td><td>货币编码</td></tr><tr><td></td><td></td><td>currency_name</td><td>N</td><td>货币名称</td></tr><tr><td>11</td><td></td><td>original_amount</td><td>N</td><td>原币金额</td></tr><tr><td>12</td><td></td><td>debit_amount</td><td>N</td><td>借方金额</td></tr><tr><td>13</td><td></td><td>credit amount</td><td>N</td><td>贷方金额</td></tr><tr><td>14</td><td></td><td>account_book_code</td><td>N</td><td>账薄编码</td></tr><tr><td>15</td><td></td><td>account_book_name</td><td>N</td><td>账薄名称</td></tr><tr><td>16</td><td></td><td>gmt_created</td><td></td><td></td></tr><tr><td>17</td><td></td><td>gmt_modified</td><td></td><td></td></tr><tr><td>18</td><td></td><td>version</td><td></td><td></td></tr><tr><td>19</td><td></td><td>is_deleted</td><td></td><td></td></tr></tbody></table><p>唯一键：年月+业务码+业务类型+平台+国别</p><ol><li>配置表：部分配置表可以通过Apolo配置实现：</li></ol><p>​    3.1  单据类型；</p><p>​    3.2  平台配置；</p><p>Q:</p><ol><li>辅助核算的存储？</li></ol><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><table><thead><tr><th>编号</th><th>枚举值</th><th>业务含义</th></tr></thead><tbody><tr><td>1</td><td></td><td>余额方向:借/贷</td></tr><tr><td>2</td><td></td><td>辅助核算：国别/平台/存货类别/供应商/部门/客户/费用项目</td></tr><tr><td>3</td><td></td><td>科目类别：资产/负债/共同/权益/成本/损益</td></tr><tr><td>4</td><td></td><td>摘要规则： 由财务确定</td></tr><tr><td>5</td><td></td><td>借贷方向：借/贷</td></tr><tr><td>6</td><td></td><td></td></tr></tbody></table><p>疑问点：</p><ol><li></li></ol><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220322104108539.png" alt="image-20220322104108539" style="zoom:50%;" /><p>是不是就是单号？（待验证）</p><ol start="4"><li><img src="/Users/xiazhenyu/Library/Application Support/typora-user-images/image-20220322104454330.png" alt="image-20220322104454330" style="zoom:50%;" /></li></ol><p>凭证编码放在凭证规则中？然后凭证明细表冗余下？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求PRD地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.huoli101.com/pages/viewpage.action?pageId=60388365&quot;&gt;http://wiki.huoli101.com/pages/viewpage.action?p</summary>
      
    
    
    
    <category term="wholee" scheme="http://example.com/categories/wholee/"/>
    
    
    <category term="wholee" scheme="http://example.com/tags/wholee/"/>
    
  </entry>
  
  <entry>
    <title>3月20号直播</title>
    <link href="http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/3%E6%9C%8820%E5%8F%B7%E7%9B%B4%E6%92%AD/"/>
    <id>http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/3%E6%9C%8820%E5%8F%B7%E7%9B%B4%E6%92%AD/</id>
    <published>2022-03-20T12:11:52.641Z</published>
    <updated>2022-03-20T14:05:52.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RDB回顾"><a href="#RDB回顾" class="headerlink" title="RDB回顾"></a>RDB回顾</h3><p>redis的判断RDB启动的条件？</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>aof_buf  AOF缓冲区</p><p>ServerCorn函数</p><p>主要作用：</p><ol><li><p>更新服务器的各项数据；</p></li><li><p>清理过期的键值对；</p></li><li><p>关闭和清理连接失效的客户端；</p></li><li><p>尝试进行AOF和RDB持久化更新；</p></li></ol><p>作业：</p><p>线上有100w条商品数据（存在于根据商家id分库分表的数据库中），分别属于1000多个商家之下。这些商家被删除，要求同步删除其商品数据。请你设计一个系统，来删除这100w条商品数据。要求如下：</p><p>1.不影响线上服务；<br>2.保证一定的删除速率；<br>3.可以统计删除时效；<br>4.可以动态调整删除速率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;RDB回顾&quot;&gt;&lt;a href=&quot;#RDB回顾&quot; class=&quot;headerlink&quot; title=&quot;RDB回顾&quot;&gt;&lt;/a&gt;RDB回顾&lt;/h3&gt;&lt;p&gt;redis的判断RDB启动的条件？&lt;/p&gt;
&lt;h3 id=&quot;AOF持久化&quot;&gt;&lt;a href=&quot;#AOF持久化&quot; cl</summary>
      
    
    
    
    <category term="拉钩" scheme="http://example.com/categories/%E6%8B%89%E9%92%A9/"/>
    
    
    <category term="拉钩" scheme="http://example.com/tags/%E6%8B%89%E9%92%A9/"/>
    
  </entry>
  
  <entry>
    <title>利用JVM命令行工具排查线上问题</title>
    <link href="http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/%E5%88%A9%E7%94%A8JVM%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%8E%92%E6%9F%A5%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/%E5%88%A9%E7%94%A8JVM%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%8E%92%E6%9F%A5%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-20T05:19:39.297Z</published>
    <updated>2022-03-20T06:19:42.379Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps</td><td>查看正在运行的java进程</td></tr><tr><td>jstack</td><td>打印线程快照</td></tr><tr><td>jmap</td><td>导出堆内存映射文件</td></tr><tr><td>jstat</td><td>查看jvm统计信息</td></tr><tr><td>jinfo</td><td>实时查看和修改jvm配置参数</td></tr><tr><td>jhat</td><td>用于分析heapdump文件</td></tr></tbody></table><h3 id="jps：查看正在运行的java进程"><a href="#jps：查看正在运行的java进程" class="headerlink" title="jps：查看正在运行的java进程"></a>jps：查看正在运行的java进程</h3><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出进程id</td></tr><tr><td>-m</td><td>输出传递给主类main函数的参数</td></tr><tr><td>-l</td><td>输出主类全类名，如果进程执行的是jar包，输出jar包的名字。</td></tr><tr><td>-v</td><td>程序启动时制定的jvm参数</td></tr></tbody></table><p>ex：</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320134743825.png" alt="image-20220320134743825" style="zoom:50%;" /><h3 id="jstack-打印线程快照"><a href="#jstack-打印线程快照" class="headerlink" title="jstack :打印线程快照"></a>jstack :打印线程快照</h3><p>查看某个java进程中所有线程的状态。一般用来定位线程出现长时间停顿的原因，如发生死循环、死锁、请求外部资源长时间等待等。</p><p>执行jstack的效果：</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320135157763.png" alt="image-20220320135157763" style="zoom:50%;" /><h3 id="jmap：导出堆内存映射文件"><a href="#jmap：导出堆内存映射文件" class="headerlink" title="jmap：导出堆内存映射文件"></a>jmap：导出堆内存映射文件</h3><p>jmap主要用来导出堆内存映射文件，看是否发生内存泄漏等；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:file=文件名.dump 进程id</span><br></pre></td></tr></table></figure><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320135611486.png" alt="image-20220320135611486" style="zoom:50%;" /><h3 id="jstat-查看jvm统计信息"><a href="#jstat-查看jvm统计信息" class="headerlink" title="jstat:查看jvm统计信息"></a>jstat:查看jvm统计信息</h3><p>jstat可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320141238863.png" alt="image-20220320141238863"></p><table><thead><tr><th>Loaded</th><th>解释</th></tr></thead><tbody><tr><td>Loaded</td><td>加载类的个数</td></tr><tr><td>Bytes</td><td>加载类的字节数</td></tr><tr><td>Unloaded</td><td>卸载类的个数</td></tr><tr><td>Bytes</td><td>卸载类的字节数</td></tr><tr><td>Time</td><td>花费的时间</td></tr></tbody></table><h3 id="jinfo：实时查看和修改jvm参数"><a href="#jinfo：实时查看和修改jvm参数" class="headerlink" title="jinfo：实时查看和修改jvm参数"></a>jinfo：实时查看和修改jvm参数</h3><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/2021070716373839.jpg" alt="在这里插入图片描述"></p><p>ex：</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320134304798.png" alt="image-20220320134304798" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;主要作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;jps&lt;/td&gt;
&lt;td&gt;查看正在运行的java进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jstack&lt;/td&gt;
&lt;td</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="工作安排" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C%E5%AE%89%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个RPC框架</title>
    <link href="http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6/</id>
    <published>2022-03-19T18:29:15.439Z</published>
    <updated>2022-03-20T05:20:22.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个RPC调用的过程如下"><a href="#一个RPC调用的过程如下" class="headerlink" title="一个RPC调用的过程如下"></a>一个RPC调用的过程如下</h2><ol><li>调用方发送请求后由代理类将调用的方法，参数组装成能进行网络传输的消息体</li><li>调用方将消息体发送到提供方</li><li>提供方将消息进行解码，得到调用的参数</li><li>提供方反射执行相应的方法，并将结果返回</li></ol><h2 id="生成代理类"><a href="#生成代理类" class="headerlink" title="生成代理类"></a>生成代理类</h2><p>fb的Thrift和Google的gRPC都是定义一个schema文件，然后执行程序，帮你生成客户端代理类以及接口。调用方直接用生成的代理类来请求，提供方继承生成的接口即可。</p><p>优点：支持多语言通信。</p><p>在Java中生成代理类的方式：</p><p>1.JDK动态代理；</p><p>2.字节码操作类库（cglib，Javassist）。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>为什么需要协议？</p><p>数据在网络中是以二进制的形式在网络中传播的，RPC的请求数据不是以一个整体发送到提供方的，而是可能被拆分成多个数据包发送出去。定义协议，可以有效的保证通信的双方进行交流。</p><p>都有哪些种类的协议呢？</p><ul><li>定长协议：协议内容固定；</li><li>特殊结束符：定义一个消息结束的分割符，如读\n，表示一个数据读取完毕了，没有就一直读；</li><li>变长协议（协议头+协议体）：用一个定长表示消息体的长度，剩下的内容表示消息体。？</li></ul><p>我们以dubbo的协议来进行说明，dubbo采用的协议被称为dubbo协议。协议的头格式如下：</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320030901386.png" alt="image-20220320030901386"></p><p>解释：</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/202010301351057.png" alt="在这里插入图片描述"></p><p>为什么要自定义协议？ 关键字：高性能</p><ol><li>Http协议的请求包比较大，有很多无用的内容，自定义协议可以精简很多的内容；</li><li>Http协议是无状态的，每次都要重新建立链接，响应完毕以后链接关闭。</li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>常用的序列化方式：</p><ol><li>JDK原生序列化；</li><li>JSON；</li><li>Protobuf；</li><li>Kryo；</li><li>Hessian2；</li><li>MessagePack；</li></ol><p>选择序列化时，需要考虑的因素：</p><ol><li>效率；</li><li>空间开销；</li><li>通用性和兼容性；</li><li>安全性。</li></ol><h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><p>这个主要指的是IO模型；</p><ol><li>BIO</li><li>NIO</li><li>IO多路复用；（Netty）</li><li>异步IO</li></ol><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>我们可以使用ZK、Redis、Nacos等多种方式实现；</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>路由策略、异常重试、监控、异步调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个RPC调用的过程如下&quot;&gt;&lt;a href=&quot;#一个RPC调用的过程如下&quot; class=&quot;headerlink&quot; title=&quot;一个RPC调用的过程如下&quot;&gt;&lt;/a&gt;一个RPC调用的过程如下&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;调用方发送请求后由代理类将调用的方法，参数组装成</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="工作安排" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C%E5%AE%89%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>常用的linux命令</title>
    <link href="http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-19T18:23:26.102Z</published>
    <updated>2022-03-19T18:27:30.427Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>编号</th><th>命令</th><th>释义</th></tr></thead><tbody><tr><td>1</td><td>ps  aux | grep redis-server</td><td>查看某个服务是否启动</td></tr><tr><td>2</td><td></td><td></td></tr><tr><td>3</td><td></td><td></td></tr></tbody></table><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220320022723660.png" alt="image-20220320022723660"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;释义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;ps  aux | grep redis-server&lt;/td&gt;
&lt;td&gt;查看某个</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>redis源码环境搭建</title>
    <link href="http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/redis/redis%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2022/03/20/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/redis/redis%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-19T16:29:16.300Z</published>
    <updated>2022-03-19T18:19:49.413Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>make和cmake 的区别</p><p>make，是一个自动化编译工具，使用一条命令实现完全编译。</p><p>makefile，是一个文件，里面定义了make需要使用到的规则，make依据makefile文件中的规则来进行编译。</p><p>cmakefile，用来自动生成makefile文件的工具。它能够输出各种各样的makefile或者是project文件。</p><p>参考博文：<a href="https://blog.csdn.net/weixin_42491857/article/details/80741060">https://blog.csdn.net/weixin_42491857/article/details/80741060</a></p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/70.png" alt="img"></p></li></ul><p>进行编译：</p><img src="/Users/xiazhenyu/Library/Application Support/typora-user-images/image-20220320021758778.png" alt="image-20220320021758778" style="zoom:25%;" /><p>配置execute：</p><img src="/Users/xiazhenyu/Library/Application Support/typora-user-images/image-20220320021452228.png" alt="image-20220320021452228" style="zoom:25%;" /><p>参考博文：<a href="https://cxybb.com/article/u011225266/116017675">https://cxybb.com/article/u011225266/116017675</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;make和cmake 的区别&lt;/p&gt;
&lt;p&gt;make，是一个自动化编译工具，使用一条命令实现完全编译。&lt;/p&gt;
&lt;p&gt;makefile，是一个文件，里面定义了make需要使用到的规则，make依据makefile文件中的规则来进行编译。&lt;/p&gt;
&lt;p&gt;cm</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/19/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/Spring%20AOP%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <id>http://example.com/2022/03/19/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/Spring%20AOP%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</id>
    <published>2022-03-18T17:03:12.253Z</published>
    <updated>2022-03-18T17:03:23.832Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>http报文的常见的错误码</title>
    <link href="http://example.com/2022/03/18/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/http%E6%8A%A5%E6%96%87%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <id>http://example.com/2022/03/18/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/http%E6%8A%A5%E6%96%87%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E7%A0%81/</id>
    <published>2022-03-18T15:59:18.287Z</published>
    <updated>2022-03-19T18:53:28.785Z</updated>
    
    <content type="html"><![CDATA[<p>Http请求报文和响应报文的格式</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20190822223354538.PNG" alt="在这里插入图片描述"></p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20190822223707561.PNG" alt="在这里插入图片描述"></p><p>常见的首部如下：</p><p><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong></p><p>Date：创建报文时间 </p><p>Connection：连接的管理 </p><p>Cache-Control：缓存的控制 </p><p>Transfer-Encoding：报文主体的传输编码方式</p><p><strong>请求首部字段（请求报文会使用的首部字段）</strong></p><p>Host：请求资源所在服务器 </p><p>Accept：可处理的媒体类型 </p><p>Accept-Charset：可接收的字符集 </p><p>Accept-Encoding：可接受的内容编码 </p><p>Accept-Language：可接受的自然语言</p><p><strong>响应首部字段（响应报文会使用的首部字段）</strong></p><p>Accept-Ranges：可接受的字节范围 </p><p>Location：令客户端重新定向到的URI </p><p>Server：HTTP服务器的安装信息</p><p><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong></p><p>Allow：资源可支持的HTTP方法 </p><p>Content-Type：实体主类的类型 </p><p>Content-Encoding：实体主体适用的编码方式 </p><p>Content-Language：实体主体的自然语言 </p><p>Content-Length：实体主体的的字节数 </p><p>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用。</p><p>==状态码的识别==</p><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>信息性状态码</td><td>收到的请求正在处理</td></tr><tr><td>2xx</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>服务端错误状态码</td><td>服务器处理请求出错</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>2xx成功：</p><table><thead><tr><th>状态码</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>表示从客户端发来的请求在服务端被正确处理</td></tr><tr><td>204</td><td>No content</td><td>表示请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>206</td><td>Partial Content</td><td>进行范围请求</td></tr></tbody></table><p>3xx 重定向</p><table><thead><tr><th>状态码</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>301</td><td>moved permanently</td><td>永久性重定向，表示资源已被分配了新的URL</td></tr><tr><td>302</td><td>found</td><td>临时性重定向，表示资源临时被分配了新的URL</td></tr><tr><td>303</td><td>see other</td><td>表示资源存在着另一个URL，应使用GET方法定向获取资源</td></tr><tr><td>304</td><td>not modified</td><td>表示服务器允许访问资源，但发生请求未满足条件的情况</td></tr><tr><td>307</td><td>temporary redirect</td><td>临时重定向，和302含义相同</td></tr></tbody></table><p>4xx客户端错误</p><table><thead><tr><th>状态码</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>400</td><td>bad request</td><td>请求报文存在语法错误</td></tr><tr><td>401</td><td>unauthorized</td><td>表示发送的请求需要有通过HTTP认证的信息</td></tr><tr><td>403</td><td>Forbidden</td><td>表示对请求资源的访问被服务器拒绝</td></tr><tr><td>404</td><td>not found</td><td>表示在服务器上没有找到请求的资源</td></tr></tbody></table><p>5xx 服务器错误</p><table><thead><tr><th>状态码</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>500</td><td>internal server error</td><td>表示服务器在执行请求时发生了错误</td></tr><tr><td>503</td><td>service unavalibale</td><td>表示服务器暂时处于超负荷或正在停机维护，无法处理请求。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Http请求报文和响应报文的格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20190822223354538.PNG&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="工作安排" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C%E5%AE%89%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>如何排查CPU飙高的问题</title>
    <link href="http://example.com/2022/03/18/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5CPU%E9%A3%99%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/03/18/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5CPU%E9%A3%99%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-18T15:20:20.450Z</published>
    <updated>2022-03-19T18:54:02.518Z</updated>
    
    <content type="html"><![CDATA[<p>如何排查CPU飙高的问题？</p><ol><li>先执行top命令，找到CPU占用比较高的进程；</li><li>jstak 进程id &gt; loop.txt（文件名可以自定义）；</li><li>找到进程中CPU占用比较高的线程，线程id转为16进制；</li><li>到show.txt文件中根据线程id查看线程的具体状态即可；</li></ol><p>Top 命令运行图：</p><img src="/Users/xiazhenyu/Library/Application Support/typora-user-images/image-20220318233143850.png" alt="image-20220318233143850" style="zoom:25%;" /><p>参数介绍：</p><p>第一行：基本信息：</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20200901231648401.png" alt="在这里插入图片描述"></p><p>第二行：任务信息</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20200901231702290.png" alt="在这里插入图片描述"></p><p>第三行：CPU使用情况</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20200901231715782.png" alt="在这里插入图片描述"></p><p>第四行：物理内存使用情况</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20200901231739883.png" alt="在这里插入图片描述"></p><p>buffer/cache</p><p>buffer 和 cache都是内存中存放的数据，不同的是，buffer存放的是准备写入磁盘的数据，而cache存放的是从磁盘中读取的数据。</p><p>在linux中，有一个守护进程（daemon）会定期把buffers中的数据写入磁盘，也可以使用sync命令手动把buffer中的数据写入磁盘。使用buffer可以把分散的I/O操作集中起来，减少了磁盘寻道的时间和磁盘碎片。</p><p>cache是linux把读取频率高的数据，放到内存中，减少I/O。linux中cache没有固定大小，根据使用情况自动增加或删除。</p><p>top中使用的参数：</p><table><thead><tr><th align="center">参数选项名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">通过指定进程ID（PID）来仅仅监控某个进程的状态。可以指定多个，-pN1 -pN2 … （-p N1 -p N2…也可）或者 -pN1,N2,N3 …（-p N1,N2…也可）</td></tr><tr><td align="center">H</td><td align="center">显示所有线程的运行状态指标。如果没有该参数，会显示一个进程中所有线程的总和。在运行过程中，可以通过H命令进行交互控制</td></tr></tbody></table><p>第一步：执行top命令。</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/2019010317460292.PNG" alt="在这里插入图片描述"></p><p>第二步：看到pid为23757的进程CPU占用较高，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 23757 &gt; loop.txt</span><br></pre></td></tr></table></figure><p>第三步：查看线程的具体执行情况；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 23757 -H</span><br></pre></td></tr></table></figure><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20190103174921118.PNG" alt="在这里插入图片描述"></p><p>可以看到PID为23772,23773和23774的线程占用CPU较高。这里注意，PID不是特指进程的ID，线程的ID也可以叫做PID；</p><p>第四步：将10进制23772转为16进制，因为jstack中PID使用的是16进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x&quot; 23772</span><br><span class="line">输出5cdc</span><br></pre></td></tr></table></figure><p>第五步：打开loop.txt文件，搜5cdc。</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/20190103175859431.png" alt="在这里插入图片描述"></p><p>即可以定位到有问题的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何排查CPU飙高的问题？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先执行top命令，找到CPU占用比较高的进程；&lt;/li&gt;
&lt;li&gt;jstak 进程id &amp;gt; loop.txt（文件名可以自定义）；&lt;/li&gt;
&lt;li&gt;找到进程中CPU占用比较高的线程，线程id转为16进制；&lt;/li</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="工作安排" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C%E5%AE%89%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>系统监控与告警</title>
    <link href="http://example.com/2022/03/17/wholee/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%91%8A%E8%AD%A6/"/>
    <id>http://example.com/2022/03/17/wholee/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%91%8A%E8%AD%A6/</id>
    <published>2022-03-17T09:29:56.686Z</published>
    <updated>2022-03-19T13:58:29.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Grafana监控大盘地址：https-monitor-huoli101-com-orgId-1"><a href="#Grafana监控大盘地址：https-monitor-huoli101-com-orgId-1" class="headerlink" title="Grafana监控大盘地址：https://monitor.huoli101.com/?orgId=1"></a>Grafana监控大盘地址：<a href="https://monitor.huoli101.com/?orgId=1">https://monitor.huoli101.com/?orgId=1</a></h2><p>应用机器监控：</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220317173810783.png" alt="image-20220317173810783" style="zoom: 25%;" /><p>例如：product-center的线上机器监控：</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220317173854433.png" alt="image-20220317173854433" style="zoom: 25%;" /><p>中间件Redis的监控，在Redis Overview中：</p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220317174058037.png" alt="image-20220317174058037" style="zoom:25%;" /><p>中间件MySQL的监控，地址：<a href="https://monitor.huoli101.com/d/MQWgroiiz/mysql-overview?orgId=1&amp;var-dataSource=%E7%BE%8E%E8%A5%BF&amp;var-interval=$__auto_interval_interval&amp;var-nodeName=product-odoo-new-mysql&amp;var-resource=product-odoo-new&amp;var-service=product-center&amp;var-jumpNode=%E5%95%86%E5%93%81%E4%B8%AD%E5%BF%83&amp;var-dataCenter=&amp;from=now-7d&amp;to=now%E3%80%82">https://monitor.huoli101.com/d/MQWgroiiz/mysql-overview?orgId=1&amp;var-dataSource=%E7%BE%8E%E8%A5%BF&amp;var-interval=$__auto_interval_interval&amp;var-nodeName=product-odoo-new-mysql&amp;var-resource=product-odoo-new&amp;var-service=product-center&amp;var-jumpNode=%E5%95%86%E5%93%81%E4%B8%AD%E5%BF%83&amp;var-dataCenter=&amp;from=now-7d&amp;to=now。</a></p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220317175040266.png" alt="image-20220317175040266" style="zoom:25%;" /><p>PS：MySQL监控中需要关注的指标：</p><ul><li>内存使用率；</li><li>QPS：</li><li>满查询sql：</li><li>客户端连接进程数；</li><li>CPU使用率：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Grafana监控大盘地址：https-monitor-huoli101-com-orgId-1&quot;&gt;&lt;a href=&quot;#Grafana监控大盘地址：https-monitor-huoli101-com-orgId-1&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="wholee" scheme="http://example.com/categories/wholee/"/>
    
    
    <category term="wholee" scheme="http://example.com/tags/wholee/"/>
    
  </entry>
  
  <entry>
    <title>dubbo接口调用</title>
    <link href="http://example.com/2022/03/17/wholee/dubbo%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2022/03/17/wholee/dubbo%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</id>
    <published>2022-03-17T08:54:48.561Z</published>
    <updated>2022-03-19T13:53:29.949Z</updated>
    
    <content type="html"><![CDATA[<p>第一步：通过跳板机登录到test或者是预发、线上的机器上；</p><p>第二步：telnet+IP地址 +20988端口，访问dubbo服务，例如：</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220317165739124.png" alt="image-20220317165739124"></p><p>然后通过ls命令可以查看有那些已经注册的服务，如下图所示：</p><img src="/Users/xiazhenyu/Library/Application Support/typora-user-images/image-20220317165830962.png" alt="image-20220317165830962" style="zoom:50%;" /><p>第三步：通过invoke 命令调用dubbo服务</p><p>例如：</p><p><code>invoke com.clubfactory.product.center.client.service.product.readonly.IProductReadOnlyAPI.getByIds([20440305])，</code></p><p>会得到如下的结果：</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220317170105865.png" alt="image-20220317170105865"></p><p>最下面会有一个耗时的统计。</p><p>PS:</p><p>可用的开源工具：<a href="https://www.cxybb.com/article/qq_31091589/98056271%EF%BC%9B">https://www.cxybb.com/article/qq_31091589/98056271；</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一步：通过跳板机登录到test或者是预发、线上的机器上；&lt;/p&gt;
&lt;p&gt;第二步：telnet+IP地址 +20988端口，访问dubbo服务，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://xiazhenyu.oss-cn-hangzhou.aliyuncs.c</summary>
      
    
    
    
    <category term="wholee" scheme="http://example.com/categories/wholee/"/>
    
    
    <category term="wholee" scheme="http://example.com/tags/wholee/"/>
    
  </entry>
  
  <entry>
    <title>宝塔相关知识</title>
    <link href="http://example.com/2022/03/12/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%9D%E5%A1%94%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/03/12/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%9D%E5%A1%94%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-12T14:38:16.285Z</published>
    <updated>2022-03-19T18:24:54.279Z</updated>
    
    <content type="html"><![CDATA[<p>1.查看面板入口：/etc/init.d/bt default</p><p>2.关闭安全入口：rm -f /www/server/panel/data/admin_path.pl</p><p>输入命令后，会得到对应的登录信息：</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220312223939647.png" alt="image-20220312223939647"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.查看面板入口：/etc/init.d/bt default&lt;/p&gt;
&lt;p&gt;2.关闭安全入口：rm -f /www/server/panel/data/admin_path.pl&lt;/p&gt;
&lt;p&gt;输入命令后，会得到对应的登录信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/12/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%80%9D%E7%BB%B4/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E5%8A%9B/"/>
    <id>http://example.com/2022/03/12/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%80%9D%E7%BB%B4/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E5%8A%9B/</id>
    <published>2022-03-12T08:24:12.484Z</published>
    <updated>2022-03-18T17:07:13.843Z</updated>
    
    <content type="html"><![CDATA[<ol><li>保持充足的睡眠。思维按摩：用拇指和食指从上到下轻轻地按摩整个耳朵，用两只手的手指触摸位于发际和眉毛之间的两个穴位。促进血液流动，消除记忆障碍和增强记忆力。</li><li>经常咀嚼。</li><li>合理饮食：<ul><li>多吃大豆和豆制品。</li><li>多吃鱼；</li><li>多吃桔子和香蕉；</li><li>多吃猪脑和鸡；</li><li>多吃蔬菜、胡萝卜、菠菜。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;保持充足的睡眠。思维按摩：用拇指和食指从上到下轻轻地按摩整个耳朵，用两只手的手指触摸位于发际和眉毛之间的两个穴位。促进血液流动，消除记忆障碍和增强记忆力。&lt;/li&gt;
&lt;li&gt;经常咀嚼。&lt;/li&gt;
&lt;li&gt;合理饮食：&lt;ul&gt;
&lt;li&gt;多吃大豆和豆制品。&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>日志查看规范</title>
    <link href="http://example.com/2022/03/11/wholee/%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/2022/03/11/wholee/%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E8%A7%84%E8%8C%83/</id>
    <published>2022-03-11T02:09:44.082Z</published>
    <updated>2022-03-19T13:54:58.184Z</updated>
    
    <content type="html"><![CDATA[<p>product-message-consumer：</p><p>日志目录：/root/logs/product-message-consumer;</p><p>发送的消息日志在kafka_producer.log中，消费的消息日志在kafka_consumer.log中；</p><p>日志的查找：</p><p>日志上报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat.logEvent(MESSAGE_COUNT_FOR_GROUP, chatId, Message.SUCCESS, msg);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;product-message-consumer：&lt;/p&gt;
&lt;p&gt;日志目录：/root/logs/product-message-consumer;&lt;/p&gt;
&lt;p&gt;发送的消息日志在kafka_producer.log中，消费的消息日志在kafka_consumer.log中</summary>
      
    
    
    
    <category term="wholee" scheme="http://example.com/categories/wholee/"/>
    
    
    <category term="wholee" scheme="http://example.com/tags/wholee/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/02/27/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E4%BD%9C%E4%B8%9A/"/>
    <id>http://example.com/2022/02/27/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E4%BD%9C%E4%B8%9A/</id>
    <published>2022-02-27T14:15:54.619Z</published>
    <updated>2022-03-12T16:38:05.759Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>编号</th><th>编码常量</th><th>对应的底层数据结构</th></tr></thead><tbody><tr><td>1</td><td>REDIS_ENCODING_INT</td><td>long类型的整数</td></tr><tr><td>2</td><td>REDIS_ENCODING_EMBSTR</td><td>embstr编码的简单动态字符串</td></tr><tr><td>3</td><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>4</td><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>5</td><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>6</td><td>REDIS_ENCODING_ZIPLIST</td><td>压缩链表</td></tr><tr><td>7</td><td>REDIS_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>8</td><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td></tr></tbody></table><p>不同类型、编码的对象</p><table><thead><tr><th>类型</th><th>编码</th><th>对象</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_INT</td><td>使用整数值实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_EMBSTR</td><td>使用embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_RAW</td><td>使用简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的列表对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_LINKEDLIST</td><td>使用双端链表是想的列表对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的哈希对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_HT</td><td>使用字典实现的哈希对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_INTSET</td><td>使用整数集合实现的集合对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_HT</td><td>使用字典实现的集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的有序集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_SKIPLIST</td><td>使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;编码常量&lt;/th&gt;
&lt;th&gt;对应的底层数据结构&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INT&lt;/td&gt;
&lt;td&gt;long</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/02/27/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E4%BD%BF%E7%94%A8Clion%E5%AF%BC%E5%85%A5%E3%80%81%E8%B0%83%E8%AF%95Redis/"/>
    <id>http://example.com/2022/02/27/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E4%BD%BF%E7%94%A8Clion%E5%AF%BC%E5%85%A5%E3%80%81%E8%B0%83%E8%AF%95Redis/</id>
    <published>2022-02-26T16:57:42.873Z</published>
    <updated>2022-02-26T16:57:57.782Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/02/26/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/02/26/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-26T15:42:46.691Z</published>
    <updated>2022-02-26T16:53:18.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><p>在C语言中，有的语句使用时不能带括号，有的语句必须带括号。带括号的称为函数（Function）。</p><p>C语言自带的函数称为库函数（Library Function）。库（Library）是编程中的一个基本概念，可以简单地认为它是一些列函数的集合，在磁盘上往往是一个文件夹。C语言自带的库称为标准库（S<a href="http://c.biancheng.net/ref/tan.html">tan</a>dard Library），其他公司或个人开发的库称为第三方库（Third-Party Library）。</p><p>C语言规定，一个程序必须有且只有一个 main 函数。main 被称为主函数，是程序的入口函数，程序运行时从 main 函数开始，直到 main 函数结束（遇到 return 或者执行到函数末尾时，函数才结束）</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>C语言开发者们编写了很多常用函数，并分门别类的放在了不同的文件，这些文件就称为头文件（header file）。每个头文件中都包含了若干个功能类似的函数，调用某个函数时，要引入对应的头文件，否则编译器找不到函数。</p><p>较早的C语言标准库包含了15个头文件，stdio.h 和 stdlib.h 是最常用的两个：</p><ul><li>stdio 是 standard input output 的缩写，stdio.h 被称为“标准输入输出文件”，包含的函数大都和输入输出有关，puts() 就是其中之一。</li><li>stdlib 是 standard library 的缩写，stdlib.h 被称为“标准库文件”，包含的函数比较杂乱，多是一些通用工具型函数，system() 就是其中之一。</li></ul><h3 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h3><p>空格、制表符、换行符等统称为空白符（space character），它们只用来占位，并没有实际的内容，也显示不出具体的字符。</p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><h4 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a>常用的数据类型</h4><table><thead><tr><th>说  明</th><th>字符型</th><th>短整型</th><th>整型</th><th>长整型</th><th>单精度浮点型</th><th>双精度浮点型</th><th>无类型</th></tr></thead><tbody><tr><td>数据类型</td><td>char</td><td>short</td><td>int</td><td>long</td><td>float</td><td>double</td><td>void</td></tr></tbody></table><h4 id="数据类型对应的长度（字节）："><a href="#数据类型对应的长度（字节）：" class="headerlink" title="数据类型对应的长度（字节）："></a>数据类型对应的长度（字节）：</h4><table><thead><tr><th>说  明</th><th>字符型</th><th>短整型</th><th>整型</th><th>长整型</th><th>单精度浮点型</th><th>双精度浮点型</th></tr></thead><tbody><tr><td>数据类型</td><td>char</td><td>short</td><td>int</td><td>long</td><td>float</td><td>double</td></tr><tr><td>长  度</td><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td><td>8</td></tr></tbody></table><p>sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略<code>( )</code>，如果跟的是数据类型，就必须带上<code>( )</code>。</p><p>%d称为格式控制符。</p><ul><li>%d 输出一个数字。</li></ul><ul><li><p>%c：输出一个字符。c 是 character 的简写。</p></li><li><p>%s：输出一个字符串。s 是 string 的简写。</p></li><li><p>%f：输出一个小数。f 是 float 的简写。</p></li><li><p><code>%hd</code>用来输出 short int 类型，hd 是 short decimal 的简写；</p></li><li><p><code>%d</code>用来输出 int 类型，d 是 decimal 的简写；</p></li><li><p><code>%ld</code>用来输出 long int 类型，ld 是 long decimal 的简写。</p></li></ul><p>在数据前面加上unsigned关键字，表示数字是无符号数，所有位上都可以表示数字。</p><h4 id="无符号数的输出："><a href="#无符号数的输出：" class="headerlink" title="无符号数的输出："></a>无符号数的输出：</h4><table><thead><tr><th></th><th>short</th><th>int</th><th>long</th><th>unsigned short</th><th>unsigned int</th><th>unsigned long</th></tr></thead><tbody><tr><td>八进制</td><td>–</td><td>–</td><td>–</td><td>%ho</td><td>%o</td><td>%lo</td></tr><tr><td>十进制</td><td>%hd</td><td>%d</td><td>%ld</td><td>%hu</td><td>%u</td><td>%lu</td></tr><tr><td>十六进制</td><td>–</td><td>–</td><td>–</td><td>%hx 或者 %hX</td><td>%x 或者 %X</td><td>%lx 或者 %lX</td></tr></tbody></table><h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p>C语言中常用的小数有两种类型，分别是 float 或 double；float 称为单精度浮点型，double 称为双精度浮点型。</p><p>输出：</p><ul><li>%f 以十进制形式输出 float 类型；</li><li>%lf 以十进制形式输出 double 类型；</li><li>%e 以指数形式输出 float 类型，输出结果中的 e 小写；</li><li>%E 以指数形式输出 float 类型，输出结果中的 E 大写；</li><li>%le 以指数形式输出 double 类型，输出结果中的 e 小写；</li><li>%lE 以指数形式输出 double 类型，输出结果中的 E 大写。</li></ul><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符以<code>\</code>或者<code>\x</code>开头，以<code>\</code>开头表示后跟八进制形式的编码值，以<code>\x</code>开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。</p><p>转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：</p><ul><li>八进制形式的转义字符最多后跟三个数字，也即<code>\ddd</code>，最大取值是<code>\177</code>；</li><li>十六进制形式的转义字符最多后跟两个数字，也即<code>\xdd</code>，最大取值是<code>\x7f</code>。</li></ul><p>完整列表：</p><table><thead><tr><th>转义字符</th><th>意义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>响铃(BEL)</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>&#39;</td><td>单引号</td><td>039</td></tr><tr><td>&quot;</td><td>双引号</td><td>034</td></tr><tr><td>\\</td><td>反斜杠</td><td>092</td></tr></tbody></table><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h2&gt;&lt;h3 id=&quot;函数：&quot;&gt;&lt;a href=&quot;#函数：&quot; class=&quot;headerlink&quot; title=&quot;函数：&quot;&gt;&lt;/a&gt;函数：&lt;/h3&gt;&lt;p&gt;在C语</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/02/25/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%BA%90%E7%A0%81/lombok/"/>
    <id>http://example.com/2022/02/25/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%BA%90%E7%A0%81/lombok/</id>
    <published>2022-02-25T01:30:37.202Z</published>
    <updated>2022-02-25T02:32:59.969Z</updated>
    
    <content type="html"><![CDATA[<p>lombok简介：<a href="https://projectlombok.org/">https://projectlombok.org/</a></p><h2 id="有关使用lombok以后对象转换失效的问题"><a href="#有关使用lombok以后对象转换失效的问题" class="headerlink" title="有关使用lombok以后对象转换失效的问题"></a>有关使用lombok以后对象转换失效的问题</h2><p>Lombok使用@Builder注解以后，使用BeanUtils.copyProperties对象转换失效的问题。</p><p>这个其实就要追根溯源的去看lombok背后的机制，我们拿一个使用了@Data+@Builder组合注解的例子来看，</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220225094148483.png" alt="image-20220225094148483"></p><p>1.0</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220225094051983.png" alt="image-20220225094051983"></p><p>1.1</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220225093933286.png" alt="image-20220225093933286"></p><p>1.2</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220225095018535.png" alt="image-20220225095018535"></p><p>1.3</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220225100305805.png" alt="image-20220225100305805"></p><p>1.4</p><p><img src="https://xiazhenyu.oss-cn-hangzhou.aliyuncs.com/common/image-20220225100747836.png" alt="image-20220225100747836"></p><p>1.5</p><p>上面的图1.1是图1.0的Java Bean添加了@Data注解之后，对生成的class文件反编译得到的类文件，可以看出，反编译得到的ShippingRuleDTO对象是有一个无参的构造函数的；图1.2是添加了@Data+@Builder组合注解以后，反编译得到的类文件，这个时候发现重新生成的ShippingRuleDTO对象已经没有了无参的构造函数了，取而代之的是一个带有参数的构造函数，这个其实是和@Builder这个注解有关系的，@Builder注解是采用了建造者设计模式，原始对象的构建是通过Builder对象的build方法创建的，而Buider对象的build方法内部其实是调用了原始对象的带有参数的构造函数,如图1.3所示。</p><p>当采用图1.4这种经过封装的对象copy方法的时候，会发现dest对象的构建需要调用对应的类的instance方法。这个方法采用无参构造器进行创建对象的实例，如图1.5所示。</p><p>解决方法，在类上添加@NoArgsConstructor、@AllArgsConstructor两个注解，注意，这两个注解必须同时添加。</p><p>延伸阅读：为什么不能单独添加@Builder+@NoArgsConstructor注解？</p><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;lombok简介：&lt;a href=&quot;https://projectlombok.org/&quot;&gt;https://projectlombok.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;有关使用lombok以后对象转换失效的问题&quot;&gt;&lt;a href=&quot;#有关使用lombok以后对象转</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/02/24/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2022/02/24/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%8B%89%E9%92%A9/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-02-24T01:55:47.803Z</published>
    <updated>2022-02-24T01:55:47.803Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="多线程和锁"><a href="#多线程和锁" class="headerlink" title="多线程和锁"></a>多线程和锁</h2><p>多线程的目的：充分利用多核CPU的并行处理的能力，加快程序的处理速度；</p><p>锁的存在的意义：控制资源的并发访问，使操作串行话；</p><h3 id="JUC相关的（AQS）"><a href="#JUC相关的（AQS）" class="headerlink" title="JUC相关的（AQS）"></a>JUC相关的（AQS）</h3><p>AQS是一个用来构建锁合同步器的框架。</p><p>原理：<br>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占有，<br>那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列实现的，即将暂时获取不到锁的线程加入到队列中。</p><ul><li>CLH队列：是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH<br>锁队列的一个结点来实现锁的分配。</li></ul><p>两种资源共享方式：</p><ol><li>Exclusive：公平锁和非公平锁。</li><li>Share：</li></ol><h3 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h3><ol><li><p>锁（Synchronized、ReentrantLock的区别）、MarkWord</p><p><em><strong>Synchronized、ReentrantLock的区别</strong></em></p><ul><li>两者都是可重入锁，什么是可重入锁？已获得锁的对象，可以再次获取锁；</li><li>Synchronized是JVM实现的，使用起来简单；ReentrantLock是一个Java提供的API，比较灵活；</li><li>Synchronized是非公平锁，ReentrantLock可以提供非公平锁和公平锁两种，利用fair参数可以控制；</li><li>都提供了等待、通知机制；<ol><li>Synchronized是利用了Obejct对象的notify和wait方法；</li><li>ReentrantLock需要借助于condition、newCondition方法</li></ol></li><li>ReentrantLock提供了中断等待机制；<code>lock.lockInterruptibly()</code></li></ul><ol start="2"><li>Java对象头的结构：</li></ol><p>MarkWord ：存储对象的hashcode、分代年龄、gc标记、同步状态、锁标志位等</p><p>kClassPointer：对象的类型指针，指向类元数据（类class文件信息，metaspace空间的方法区）</p><p><em><strong>Synchronized的优化&amp;Mark word 的结构</strong></em><br><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/MarkWord%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="MarkWord的结构"></p><p>2.1 无锁（01），所有线程均可以修改某一个资源的值，但同时只能由一个线程修改成功，其他会循环尝试；<br>2.2 偏向锁（01）：在对象头MarkWord中存放有对应的线程的id，如果发现请求线程是同一个的话，再次请求的时候，直接获取锁；<br>偏向锁的一个撤销 ：全局安全点（没有字节码在执行），暂停拥有偏向锁的线程，并判断对象是否处于被锁定的状态，如果没有的话，则把对象置为无锁状态，并撤销偏向锁，恢复到无锁或者轻量级锁状态；<br>2.3 轻量级锁（00）：如果在偏向锁的过程中，有其他的线程进行请求的话，就会转化为轻量级锁，或者是关闭偏向锁功能的时候（即2.2种描述的）。线程的栈帧中有一个Lock record的区域，拷贝一份Mark word到这个区域。线程会通过CAS操作，尝试讲Mark word 更新为这个栈帧中锁记录的指针，同时，LockRecord 中的owner指针也会指向Mark word。更新成功，线程就拥有对象的锁。如果CAS失败，判断Mark word是否指向当前线程的指针，是的话，就直接进入同步代码块继续执行。</p><p>另一个线程会自旋，当自旋超过一定次数之后，会膨胀为重量级锁。（自适应自旋）；另一个升级为重量级锁的原因是这个时候有另外的线程<br>来争抢对象的锁；<br>2.4 重量级锁（10）：每一个对象都有一个ObjectMonitor锁对象。重量级锁的时候，mark word中存储的是这个monitor锁的指针，<br>另外monitor中，有一个owner指针，指向拥有锁的线程。ObjectMonitor对象内部结构：<br>entryList： 在进入或者重新进入时被阻塞的线程；<br>waitSet：在改Monitor上等待的线程；<br>owner： monitor的所有者（线程）；<br>这个monitor里面表示count（计数器），用于CAS操作。一次CAS操作成功，owner就会置换为指向对应最线程的指针；<br>利用Mutex Lock这个系统提供的来实现，来进行加锁，缺点：需要从内核态切换到用户态，比较消耗性能；</p><p>同时，每一个线程都有一个monitor record列表。<br><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/ObjectMonitor%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.png" alt="ObjectMonitor加锁流程"></p><p>2.5 GC标记（11）</p><ol start="3"><li>如何避免线程死锁？</li></ol><p>线程死锁的四个条件：</p><ul><li>互斥条件： 改资源任一时刻只能由一个线程占有；</li><li>请求与保持条件： 一个线程因请求资源而阻塞时，对已获得资源保持不放；</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕之后才能释放资源；</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系；</li></ul><p>破坏死锁的话，需要从2至4三个点来进行考虑。</p><ol><li>一次申请所有资源；</li><li>占用部分资源的线程进一步申请其他资源失败时，可以主动释放掉自己占有的资源；</li><li>按照某一个顺序申请资源，释放的时候，反序释放；</li></ol><h3 id="线程池：常用的线程池；优缺点；常用参数"><a href="#线程池：常用的线程池；优缺点；常用参数" class="headerlink" title="线程池：常用的线程池；优缺点；常用参数"></a>线程池：常用的线程池；优缺点；常用参数</h3><ul><li><p>常用线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个固定大小（核心线程数、最大线程数）的线程池，队列是LinkedBlockingQueue。缺点：容易造成OOM；</span></span><br><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//核心线程数是0，最大线程数是Integer.MAX_VALUE，队列是SynchronousQueue的线程池。SynchronousQueue不进行线程的保存，直接进行转发。容易造成OOM；</span></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//核心线程是是1个、最大线程是1个，队列是LinkedBlockingQueue（无限大）的线程池，容易造成OOM；</span></span><br><span class="line">ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//核心线程数固定大小的延迟执行的一个线程池，最大线程池大小是Integer.MAX_VALUE,队列是延迟队列：DelayedWorkQueue。缺点：容易造成OOM；</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//自定义线程池,IO密集型和CPU密集型的区别</span></span><br><span class="line"><span class="keyword">int</span> coreThreads = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> maxThreads = <span class="number">100</span>;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(coreThreads, maxThreads,</span><br><span class="line"><span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> ArrayBlockingQueue(<span class="number">500</span>));</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code> 建议的方法：自定义一个线程池:</code></pre><ul><li><p>线程池的执行流程</p><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池的执行流程"></p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？"><a href="#什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？" class="headerlink" title="什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？"></a>什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？</h4><p>见JVM。</p><h4 id="队列-amp-常用多线程工具"><a href="#队列-amp-常用多线程工具" class="headerlink" title="队列&amp;常用多线程工具"></a>队列&amp;常用多线程工具</h4><ol><li>ForkJoin</li><li>队列</li></ol><h4 id="上下文切换，"><a href="#上下文切换，" class="headerlink" title="上下文切换，"></a>上下文切换，</h4><p>Linux操作系统的上下文切换时间为什么很少？零拷贝。</p><p>零拷贝技术，sendfile！只需要2次切换、2次拷贝</p><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="零拷贝"></p><p>mmap技术： 4次切换、3次拷贝</p><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/mmap.png" alt="mmap"></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ol><li>ThreadLocalMap是ThreadLocal的静态内部类</li></ol><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/ThreadLocal%E7%BB%93%E6%9E%84.png" alt="ThreadLocal结构"></p><ol start="2"><li><p>内存泄漏：</p><p>ThreadLocalMap中key为ThreadLocal的弱引用，而value是强引用。所以，如果ThreadLocal没有被引用的话，在gc时，key会被清理掉，而value不会。</p><p>那么这个时候，就会出现key为null的entry，发生内存泄漏。<br>解决方法：手动调用remove方法，看源码可以发现，在执行set、get方法之后，顺便把路上无效的entry用线性清扫清除掉，也可以起到一定的解决内存泄漏的问题。但是get、set方法发起无效key的清理都是有触发条件的，一般都是发现key匹配不到，</p><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key&#x27;s hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1706127">get、set方法是否确定可以解决内存泄漏问题？</a>，这个看了，感觉因该是可以的，只不过是在特定的条件下。</p></li></ol><h2 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM 内存模型"></a>JMM 内存模型</h2><h3 id="JMM与happen-before"><a href="#JMM与happen-before" class="headerlink" title="JMM与happen-before"></a>JMM与happen-before</h3><p>L1、L2、L3和主内存之间是同步的，有缓存一致性MESI协议的保证，但是Store Buffer、Load Buffer和L1之间却是异步的。内存中写入一个变量，这个变量会保存在Store Buffer中，稍后才异步的写入L1中，同时同步写入主内存中。</p><h4 id="重排序与内存可见性的关系："><a href="#重排序与内存可见性的关系：" class="headerlink" title="重排序与内存可见性的关系："></a>重排序与内存可见性的关系：</h4><p>Store Buffer的延迟写入是重排序的一种，我们称之为内存重排序（Memory Ordering）。除此之外，还有编译器和CPU指令的重排序。</p><p>重排序类型：</p><ol><li>编译器重排序：对于没有先后依赖关系的语句，编译器可以重新调整语句的执行顺序；</li><li>CPU指令重排序：在指令级别，让没有依赖关系的多条执行并行；</li><li>CPU内存重排序：CPU有自己的缓存，指令的执行顺序和写入主内存的顺序不完全一致。</li></ol><p><em><strong>PS：第三种重排序是造成内存可见性问题的主因；</strong></em></p><h4 id="内存屏障："><a href="#内存屏障：" class="headerlink" title="内存屏障："></a>内存屏障：</h4><p>为了禁止编译器重排序和CPU重排序，在编译器和CPU层面都有对应的指令，也就是内存屏障（Memory Barrier）。这也正是JMM和happen-before规则的底层实现原理。</p><p>四种CPU内存屏障：</p><ol><li>LoadLoad：禁止读和读的重排序；</li><li>StoreStore：禁止写和写的重排序；</li><li>LoadStore：禁止读和写的重排序；</li><li>StoreLoad：禁止写和读的重排序；</li></ol><p>As-if-serial语义： 只要操作之间没有数据的依赖性，编译器和CPU都可以任意重排序，因为执行结果不会改变，代码看起来像是完全串行地一行一行从头执行到尾，这也就是as-if-serial语义。</p><p>编译器和CPU只能保证每一个线程的as-if-serial语义。线程之间的数据依赖和影响，需要编译器和CPU的上层来确定。</p><h4 id="happen-before定义："><a href="#happen-before定义：" class="headerlink" title="happen-before定义："></a>happen-before定义：</h4><p>描述了两个操作之间的内存可见性。</p><p>如果A happen before B，意味着A的执行结果必须对B可见，也就是保证跨线程的内存可见性。</p><p>A happen before B不代表A一定能在B之前执行，只确保如果A在B之前执行，则A的执行结果必须对B可见。<br>JMM对开发者作出的一系列的承诺：</p><ol><li>单线程中的每个操作，happen-before 对应线程中任意后续的操作（as-if-serial语义保证）；</li><li>对volatile变量的写入，happen-before对应后续对这个变量的读取；</li><li>对synchronized的解锁，happen-before对应后续对这个锁的加锁；</li><li>对final变量的写，happen-before于final域对象的读，happen-before于后续对final变量的读；</li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile的三重功效：64位写入的原子性保障、内存可见性、禁止重排序；</p><p>实现原理：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;多线程和锁&quot;&gt;&lt;a href=&quot;#多线程和锁&quot; class=&quot;headerlink&quot; title=&quot;多线程和锁&quot;&gt;&lt;/a&gt;多线程和锁&lt;/h2&gt;&lt;p&gt;多线程的目的：充分利用多核CPU的并行处理的能力，加快程序的处理速度；&lt;/p&gt;
&lt;p&gt;锁的</summary>
      
    
    
    
    
  </entry>
  
</feed>
