<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>技术、生活、思考</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="技术、生活、思考" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">技术、生活、思考</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/categories/" class="menu-item-link">Categories</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags/" class="menu-item-link">Tags</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title"></h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2022-01-15</span>
  </div>
  <div class="post-content">
    <p>[TOC]</p>
<h2 id="多线程和锁"><a href="#多线程和锁" class="headerlink" title="多线程和锁"></a>多线程和锁</h2><h4 id="多线程的目的与意义是什么？"><a href="#多线程的目的与意义是什么？" class="headerlink" title="多线程的目的与意义是什么？"></a>多线程的目的与意义是什么？</h4><ul>
<li><p>多线程的目的：充分利用多核CPU的并行处理的能力，加快程序的处理速度；</p>
</li>
<li><p>锁的存在的意义：控制资源的并发访问，使操作串行话；</p>
</li>
</ul>
<h3 id="JUC相关的（AQS）"><a href="#JUC相关的（AQS）" class="headerlink" title="JUC相关的（AQS）"></a>JUC相关的（AQS）</h3><p>AQS是一个用来构建锁合同步器的框架。</p>
<h4 id="请解释一下AQS的原理？"><a href="#请解释一下AQS的原理？" class="headerlink" title="请解释一下AQS的原理？"></a>请解释一下AQS的原理？</h4><ol>
<li>原理：<br>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占有，<br>那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列实现的，即将暂时获取不到锁的线程加入到队列中。</li>
</ol>
<ul>
<li>CLH队列：是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH<br>锁队列的一个结点来实现锁的分配。</li>
</ul>
<ol start="2">
<li><p>两种资源共享方式：</p>
</li>
<li><p>Exclusive：公平锁和非公平锁。</p>
</li>
<li><p>Share：</p>
</li>
</ol>
<h3 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h3><h4 id="请解释下锁（Synchronized、ReentrantLock的区别）？"><a href="#请解释下锁（Synchronized、ReentrantLock的区别）？" class="headerlink" title="请解释下锁（Synchronized、ReentrantLock的区别）？"></a>请解释下锁（Synchronized、ReentrantLock的区别）？</h4><p><em><strong>Synchronized、ReentrantLock的区别</strong></em></p>
<ul>
<li>两者都是可重入锁，什么是可重入锁？已获得锁的对象，可以再次获取锁；</li>
<li>Synchronized是JVM实现的，使用起来简单；ReentrantLock是一个Java提供的API，比较灵活；</li>
<li>Synchronized是非公平锁，ReentrantLock可以提供非公平锁和公平锁两种，利用fair参数可以控制；</li>
<li>都提供了等待、通知机制；<ol>
<li>Synchronized是利用了Obejct对象的notify和wait方法；</li>
<li>ReentrantLock需要借助于condition、newCondition方法</li>
</ol>
</li>
<li>ReentrantLock提供了中断等待机制；<code>lock.lockInterruptibly()</code></li>
</ul>
<h4 id="请说下java对象头的结构：？"><a href="#请说下java对象头的结构：？" class="headerlink" title="请说下java对象头的结构：？"></a>请说下java对象头的结构：？</h4><p>MarkWord ：存储对象的hashcode、分代年龄、gc标记、同步状态、锁标志位等</p>
<p>kClassPointer：对象的类型指针，指向类元数据（类class文件信息，metaspace空间的方法区）</p>
<h4 id="Synchronized的优化-amp-Mark-word-的结构"><a href="#Synchronized的优化-amp-Mark-word-的结构" class="headerlink" title="Synchronized的优化&amp;Mark word 的结构"></a><em><strong>Synchronized的优化&amp;Mark word 的结构</strong></em></h4><p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/MarkWord%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="MarkWord的结构"></p>
<p>2.1 无锁（01），所有线程均可以修改某一个资源的值，但同时只能由一个线程修改成功，其他会循环尝试；<br>2.2 偏向锁（01）：在对象头MarkWord中存放有对应的线程的id，如果发现请求线程是同一个的话，再次请求的时候，直接获取锁；<br>偏向锁的一个撤销 ：全局安全点（没有字节码在执行），暂停拥有偏向锁的线程，并判断对象是否处于被锁定的状态，如果没有的话，则把对象置为无锁状态，并撤销偏向锁，恢复到无锁或者轻量级锁状态；<br>2.3 轻量级锁（00）：如果在偏向锁的过程中，有其他的线程进行请求的话，就会转化为轻量级锁，或者是关闭偏向锁功能的时候（即2.2种描述的）。线程的栈帧中有一个Lock record的区域，拷贝一份Mark word到这个区域。线程会通过CAS操作，尝试讲Mark word 更新为这个栈帧中锁记录的指针，同时，LockRecord 中的owner指针也会指向Mark word。更新成功，线程就拥有对象的锁。如果CAS失败，判断Mark word是否指向当前线程的指针，是的话，就直接进入同步代码块继续执行。</p>
<p>另一个线程会自旋，当自旋超过一定次数之后，会膨胀为重量级锁。（自适应自旋）；另一个升级为重量级锁的原因是这个时候有另外的线程<br>来争抢对象的锁；<br>2.4 重量级锁（10）：每一个对象都有一个ObjectMonitor锁对象。重量级锁的时候，mark word中存储的是这个monitor锁的指针，<br>另外monitor中，有一个owner指针，指向拥有锁的线程。ObjectMonitor对象内部结构：<br>entryList： 在进入或者重新进入时被阻塞的线程；<br>waitSet：在改Monitor上等待的线程；<br>owner： monitor的所有者（线程）；<br>这个monitor里面表示count（计数器），用于CAS操作。一次CAS操作成功，owner就会置换为指向对应最线程的指针；<br>利用Mutex Lock这个系统提供的来实现，来进行加锁，缺点：需要从内核态切换到用户态，比较消耗性能；</p>
<p>同时，每一个线程都有一个monitor record列表。<br><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/ObjectMonitor%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.png" alt="ObjectMonitor加锁流程"></p>
<p>2.5 GC标记（11）</p>
<ol start="3">
<li>如何避免线程死锁？</li>
</ol>
<p>线程死锁的四个条件：</p>
<ul>
<li>互斥条件： 改资源任一时刻只能由一个线程占有；</li>
<li>请求与保持条件： 一个线程因请求资源而阻塞时，对已获得资源保持不放；</li>
<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕之后才能释放资源；</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系；</li>
</ul>
<p>破坏死锁的话，需要从2至4三个点来进行考虑。</p>
<ol>
<li>一次申请所有资源；</li>
<li>占用部分资源的线程进一步申请其他资源失败时，可以主动释放掉自己占有的资源；</li>
<li>按照某一个顺序申请资源，释放的时候，反序释放；</li>
</ol>
<h3 id="说下线程池：常用的线程池；优缺点；常用参数"><a href="#说下线程池：常用的线程池；优缺点；常用参数" class="headerlink" title="说下线程池：常用的线程池；优缺点；常用参数"></a>说下线程池：常用的线程池；优缺点；常用参数</h3><ul>
<li><p>常用线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个固定大小（核心线程数、最大线程数）的线程池，队列是LinkedBlockingQueue。缺点：容易造成OOM；</span></span><br><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//核心线程数是0，最大线程数是Integer.MAX_VALUE，队列是SynchronousQueue的线程池。SynchronousQueue不进行线程的保存，直接进行转发。容易造成OOM；</span></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//核心线程是是1个、最大线程是1个，队列是LinkedBlockingQueue（无限大）的线程池，容易造成OOM；</span></span><br><span class="line">ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//核心线程数固定大小的延迟执行的一个线程池，最大线程池大小是Integer.MAX_VALUE,队列是延迟队列：DelayedWorkQueue。缺点：容易造成OOM；</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//自定义线程池,IO密集型和CPU密集型的区别</span></span><br><span class="line"><span class="keyword">int</span> coreThreads = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> maxThreads = <span class="number">100</span>;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(coreThreads, maxThreads,</span><br><span class="line"><span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> ArrayBlockingQueue(<span class="number">500</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<pre><code> 建议的方法：自定义一个线程池:
</code></pre>
<ul>
<li><p>线程池的执行流程</p>
<p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池的执行流程"></p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？"><a href="#什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？" class="headerlink" title="什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？"></a>什么事OOM？如何理解？怎么排查OOM？内存泄漏和OOM的区别？</h4><p>见JVM。</p>
<h4 id="都有哪些队列-amp-常用多线程工具？"><a href="#都有哪些队列-amp-常用多线程工具？" class="headerlink" title="都有哪些队列&amp;常用多线程工具？"></a>都有哪些队列&amp;常用多线程工具？</h4><ol>
<li>ForkJoin</li>
<li>队列</li>
</ol>
<h4 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h4><p>Linux操作系统的上下文切换时间为什么很少？零拷贝。</p>
<p>零拷贝技术，sendfile！只需要2次切换、2次拷贝</p>
<p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="零拷贝"></p>
<p>mmap技术： 4次切换、3次拷贝</p>
<p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/mmap.png" alt="mmap"></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ol>
<li>ThreadLocalMap是ThreadLocal的静态内部类</li>
</ol>
<p><img src="/Users/xiazhenyu/Desktop/typora%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88/%E6%96%87%E6%A1%A3%E5%90%88%E9%9B%86/ThreadLocal%E7%BB%93%E6%9E%84.png" alt="ThreadLocal结构"></p>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    chenyusharp
  </span>
</footer>
    </div>
  </body>
</html>